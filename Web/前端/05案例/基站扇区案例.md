案例来源：https://blog.csdn.net/qq_40922589/article/details/106288054

```html
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
	<style type="text/css">
		body, html{width: 100%;height: 100%;margin:0;font-family:"微软雅黑";}
		#allmap{height:100%;width:100%;}
		#r-result{width:100%;}
        #control {
        position: absolute;
        bottom: 15px;
    }
    .button {
        margin: 5px;
        padding: 13px 23px;
        border-radius: 10px;
        box-shadow: 0 3px 14px rgba(0, 0, 0, 0.4);
        font: 16px/14px Tahoma, Verdana, sans-serif;
        text-align: center;
        color: #fefefe;
        background: #1e90ff;
    }
	</style>
	 <script type="text/javascript" src="http://api.map.baidu.com/api?v=3.0&ak=qw9LfQnzzB9P3Yny4vhPVdElp2IcCDud"></script>
	<title>基站地图</title>
</head>
<body>
  
   
    <div id="allmap"></div>
    <!-- <p>在地图上添加一个椭圆，圆的颜色为蓝色、线宽6px、透明度为1，填充颜色为白色，透明度为0.5</p> -->
    <div id="control">
        <div onclick="showOver()" class="button">显示扇区</div>
        <div onclick="hideOver()" class="button">隐藏扇区</div>
        <div onclick="showLabel()" class="button">显示标签</div>
        <div onclick="hideLabel()" class="button">隐藏标签</div>
    </div>
    
        
   
</body>
 </html>
<script type="text/javascript">
// 百度地图API功能
var map = new BMap.Map("allmap");
var point = new BMap.Point(126.532, 43.877);
map.centerAndZoom(point, 13);

//点经纬度
var mapPoints = [
    ['317443', '11', '5704单管塔', '5704单管塔_1', '1', '宏站', 126.42956333622031, 44.00636957571581, '30', '90', '1650', '华为\n'], 
    ['317443', '21', '5704单管塔', '5704单管塔_2', '2', '宏站', 126.42956333622031, 44.00636957571581, '200', '317', '1650', '华为\n'], 
    ['317443', '81', '5704单管塔', '5704单管塔_2（2100MCA）', '8', '宏站', 126.42956333622031, 44.00636957571581, '200', '317', '350', '华为\n']
];

    //centre:椭圆中心点,X:横向经度,Y:纵向纬度
    // function add_oval(centre, x, y) {
    //     var assemble = new Array();
    //     var angle;
    //     var dot;
    //     var tangent = x / y;
    //     for(i = 0; i < 36; i++) {
    //         angle = (2 * Math.PI / 36) * i;
    //         dot = new BMap.Point(centre.lng + Math.sin(angle) * y * tangent, centre.lat + Math.cos(angle) * y);
    //         assemble.push(dot);
    //     }
    //     return assemble;
    // }

    //以画多边形区域的方法画扇形区域 画出以point2点为圆心，半径为radius，夹角从sDegree到eDegree的扇形
    //Sector1(point,300,10,60,"hello")
    function Sector1(point2, radius, sDegree, eDegree, opts) {
        var points = []; //创建构成多边形的点数组  
        var step = ((eDegree - sDegree) / 10) || 10; //根据扇形的总夹角确定每步夹角度数，最大为10  
        points.push(point2);
        for(var i = sDegree; i < eDegree + 0.001; i += step) { //循环获取每步的圆弧上点的坐标，存入点数组 
            points.push(EOffsetBearing(point2, radius, i));
        }
        points.push(point2);
        if(sDegree == eDegree) {
            var planepoint = points[1];
            // var myIcon = new BMap.Icon("../images/uav.png",
            //     new BMap.Size(36, 36));
            var marker = new BMap.Marker(planepoint);
            // , {icon: myIcon}
            // );
            var opts = {
                width : 200,     // 信息窗口宽度
                height: 100,     // 信息窗口高度
                title : "海底捞王府井店" , // 信息窗口标题
                };
            map.addOverlay(marker);  
            var infoWindow = new BMap.InfoWindow("信息:", opts); // 创建信息窗口对象
            marker.addEventListener("click", function() {
                map.openInfoWindow(infoWindow, planepoint); // 开启信息窗口
                //window.external.Test(sDegree);
            });
        
            map.addOverlay(marker);
        }
        return points;
    }

    //使用数学的方法计算需要画扇形的圆弧上的点坐标
    function EOffsetBearing(point3, dist, bearing) {
        var lngConv = map.getDistance(point3, new BMap.Point(point3.lng + 0.1, point3.lat)) * 10; //计算1经度与原点的距离
        var latConv = map.getDistance(point3, new BMap.Point(point3.lng, point3.lat + 0.1)) * 10; //计算1纬度与原点的距离
        var lat = dist * Math.sin(bearing * Math.PI / 180) / latConv; //正弦计算待获取的点的纬度与原点纬度差
        var lng = dist * Math.cos(bearing * Math.PI / 180) / lngConv; //余弦计算待获取的点的经度与原点经度差
        return new BMap.Point(point3.lng + lng, point3.lat + lat);
    }
    
    // 创建扇形
    function makesectors(mapPoints){
        // 读取数据
        for(var i=0;i<mapPoints.length;i++){
            //判断是否是宏站还是室分
            if(mapPoints[i][5] == '宏站') {         
                var point = new BMap.Point(mapPoints[i][6], mapPoints[i][7]);//取经纬度
                var content = mapPoints[i][3];      //取得扇区小区信息                
                var x = mapPoints[i][9]%3;//计算PCI模几
                switch(x) {//判断PCI的模几
                    case 0://模0的颜色与样式
                        var opt = {
                            strokeColor: "red",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"red",
                            setFillOpacity: 0.5
                        }
                        break;
                    case 1://模1的颜色与样式
                        var opt = {
                            strokeColor: "green",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"green",
                            setFillOpacity: 0.5
                        }
                        break;
                    case 2://模2的颜色与样式
                        var opt = {
                            strokeColor: "blue",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"blue",
                            setFillOpacity: 0.5
                        }
                        break;
                } 
                var freqx = Number(mapPoints[i][10])//频点
                // alert(freqx);
                switch(freqx) {//判断PCI的模几
                    case 1650://模0的颜色与样式
                        var radiusx = 250
                        var widthx =20
                        break;
                    case 1506://模1的颜色与样式
                        var radiusx = 230
                        var widthx =25
                        break;
                    case 350://模2的颜色与样式
                        var radiusx = 200
                        var widthx =30
                        break;
                    case 3715://模2的颜色与样式
                        var radiusx = 300
                        var widthx =10
                        break;
                    case 1825://模0的颜色与样式
                        var radiusx = 250
                        var widthx =20
                        break;
                    case 375://模2的颜色与样式
                        var radiusx = 200
                        var widthx =30
                        break;
                } 
                //画多边形图案
                var azimuth1 = 90-mapPoints[i][8]-widthx;
                var azimuth2 = 90-mapPoints[i][8]+widthx;
                var oval = new BMap.Polygon(Sector1(point,radiusx,azimuth1,azimuth2,"hello"), opt);
                map.addOverlay(oval);//添加多边形 
                var centerPoint = oval.getBounds().getCenter();
                    //获得中心点
                    //给多边形添加标签
                    var sectorName = 
                    '<div>' +
                    '<div style="transform: translateX(-50%);' +
                    'position: absolute;background-color:rgba(255,255,255,0.6);font: 16px/14px Tahoma, Verdana, sans-serif;text-align: center;margin: 3px;padding: 3px 3px;border-radius: 5px;' +
                    'left: 50%;">'+ 
                    // margin: 5px;
                    // padding: 13px 23px;
                    // border-radius: 10px;
                    // box-shadow: 0 3px 14px rgba(0, 0, 0, 0.4);
                    // font: 16px/14px Tahoma, Verdana, sans-serif;
                    // text-align: center;
                    // color: #fefefe;
                    // 
                    '<div>' + mapPoints[i][3] +'</div></div>'; 
                     +
                    '</div>';

                    var label=new BMap.Label(sectorName, {offset:new BMap.Size(0,0), position:centerPoint});
                    map.addOverlay(label);                 
                addClickHandler(content,oval);//添加鼠标点击后显示信息窗口
                addmouseoverer(oval);//添加鼠标悬停动作
                addmouseouter(oval);//鼠标离开动作  
            }   
             //判断是否是室分
            else if (mapPoints[i][5] == '室分') {
                var point = new BMap.Point(mapPoints[i][6], mapPoints[i][7]);//取经纬度
                var content = mapPoints[i][3];      //取得扇区小区信息   
                var x = mapPoints[i][9]%3;//计算PCI模几
                switch(x) {//判断PCI的模几
                    case 0://模0的颜色与样式
                        var opt = {
                            strokeColor: "red",
                            strokeWeight: 2,
                            strokeOpacity: 0.5,
                            fillColor:"red",
                            setFillOpacity: 0.5
                        }
                        break;

                    case 1://模1的颜色与样式
                        var opt = {
                            strokeColor: "green",
                            strokeWeight: 2,
                            strokeOpacity: 0.5,
                            fillColor:"green",
                            setFillOpacity: 0.5
                        }
                        break;

                    case 2://模2的颜色与样式
                        var opt = {
                            strokeColor: "blue",
                            strokeWeight: 2,
                            strokeOpacity: 0.5,
                            fillColor:"blue",
                            setFillOpacity: 0.5
                        }
                        break;
                }   
                //创建正方形
                var d = 0.001//定义室分方形的大小
                //定义4个点
                var point1 =new BMap.Point(mapPoints[i][6]+d/2, mapPoints[i][7]+d/3)
                var point2 =new BMap.Point(mapPoints[i][6]+d/2, mapPoints[i][7]-d/3)
                var point3 =new BMap.Point(mapPoints[i][6]-d/2, mapPoints[i][7]-d/3)
                var point4 =new BMap.Point(mapPoints[i][6]-d/2, mapPoints[i][7]+d/3)
                //画方形
                var square = new  BMap.Polygon([point1,point2,point3,point4], opt)
                map.addOverlay(square);//添加正方形     
                var centerPoint = square.getBounds().getCenter();
                    //获得中心点
                    //给多边形添加标签
                    var sectorName = mapPoints[i][3];
                    var label=new BMap.Label(sectorName, {offset:new BMap.Size(0,0), position:centerPoint});
                    map.addOverlay(label);                              
                addClickHandler(content,square);//添加鼠标点击后显示信息窗口
                addmouseoverer(square);//添加鼠标悬停动作
                addmouseouter(square);//鼠标离开动作  
            }
            else{
                var point = new BMap.Point(mapPoints[i][6], mapPoints[i][7]);//取经纬度
                var content = mapPoints[i][3];      //取得扇区小区信息   
                var azimuth1 = 90-mapPoints[i][8]-20;
                var azimuth2 = 90-mapPoints[i][8]+20;
                var x = mapPoints[i][9]%3;//计算PCI模几
                switch(x) {//判断PCI的模几
                    case 0://模0的颜色与样式
                        var opt = {
                            strokeColor: "red",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"red",
                            setFillOpacity: 0.5
                        }
                        break;
                    case 1://模1的颜色与样式
                        var opt = {
                            strokeColor: "green",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"green",
                            setFillOpacity: 0.5
                        }
                        break;
                    case 2://模2的颜色与样式
                        var opt = {
                            strokeColor: "blue",
                            strokeWeight: 1,
                            strokeOpacity: 0.5,
                            fillColor:"blue",
                            setFillOpacity: 0.5
                        }
                        break;
                } 
                //画多边形图案
                var oval = new BMap.Polygon(Sector1(point,250,azimuth1,azimuth2,"hello"), opt);
                map.addOverlay(oval);//添加多边形   
                var centerPoint = oval.getBounds().getCenter();
                    //获得中心点
                    //给多边形添加标签
                    var sectorName = mapPoints[i][3];
                    var label=new BMap.Label(sectorName, {offset:new BMap.Size(0,0), position:centerPoint});
                    map.addOverlay(label);          
                             
                addClickHandler(content,oval);//添加鼠标点击后显示信息窗口
                addmouseoverer(oval);//添加鼠标悬停动作
                addmouseouter(oval);//鼠标离开动作  
            }
        }   
    }    
    // 点击事件
    function addClickHandler(content,marker){
		marker.addEventListener("click",function(){
			openInfo(content,marker.getBounds().getCenter())
            }
		);
	}
    // 定义信息窗口样式
    var opts = {
				width : 250,     // 信息窗口宽度
				height: 80,     // 信息窗口高度
				title : "信息窗口" , // 信息窗口标题
				enableMessage:true//设置允许信息窗发送短息
			   };
    // 打开信息窗口

	function openInfo(content,infopoint){    
		var infoWindow = new BMap.InfoWindow(content,opts);  // 创建信息窗口对象 
		map.openInfoWindow(infoWindow,infopoint); //开启信息窗口
	}      
    // 鼠标飘过
    function addmouseoverer(oval){
        oval.addEventListener("mouseover",function(){
            // oval.setStrokeColor("red");
            oval.setStrokeWeight(2);//边界变宽
            oval.setStrokeOpacity(1);//边界颜色变深
            oval.setFillOpacity(1);//填充颜色变深          
                // map.addOverlay(secRingLabel);
                // map.panTo(secRingCenter);
        });
    }   

    // 鼠标移开
    function addmouseouter(oval){
        oval.addEventListener("mouseout",function(){
            oval.setStrokeWeight(1);//边界恢复
            oval.setStrokeOpacity(.5);//边界透明度变化
            oval.setFillOpacity(.5);//填充颜色变化
                // map.removeOverlay(secRingLabel);
        });
    }
           
makesectors(mapPoints);
map.addControl(new BMap.NavigationControl());
map.addControl(new BMap.ScaleControl());    
map.addControl(new BMap.OverviewMapControl());    
map.addControl(new BMap.MapTypeControl());  
map.enableScrollWheelZoom();   

function showOver(){
		var markers = map.getOverlays();
        for (var i = 0; i < markers.length; i++) {         
                 markers[i].show();
           
        }
    }

function hideOver(){
    var markers = map.getOverlays();
    for (var i = 0; i < markers.length; i++) {
        console.log(markers[i].toString());
        markers[i].hide();
    }
}

function showLabel(){
		var markers = map.getOverlays();
        for (var i = 0; i < markers.length; i++) {
            if (markers[i].toString() == "[object Label]") {
                 markers[i].show();
            }
        }
    }

function hideLabel(){
    var markers = map.getOverlays();
    for (var i = 0; i < markers.length; i++) {
        if (markers[i].toString() == "[object Label]") {
                markers[i].hide();
        }
    }
}

</script>
```

